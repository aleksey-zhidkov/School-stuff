use strict;

my @query = (split/ /, $ARGV[0]);                           # переменная хранящая елты запроса (select,[*|cname],from,table,where,conds
if ($query[0] eq "help")          # если юзер запросил помощи....
{
  print "Query must be like:\n";   # оказываем
  print "select [*|colsname] from filename [where {{and|or} {cond1;cond2;cond3...}}] [orderby colname [desc]]\n";
  print "update {colname1=value1;colname2=value2...} from filename [where {{and|or} {cond1;cond2;cond3...}}]\n";
  print "insert {value1,value2,...,colnumbers} into filename\n";
  print "delete {*} from filename [where {{and|or} {cond1;cond2;cond3...}}]\n";  
  exit;
}
my $f = $query[3];                                                    # имя файла
open FH, '<', $f or die "Cannot open file $query[3]: $!";  #Открытие файла или выход из программы в случае невозможности
my $s=<FH>;                                                           # считываем заголовки колонок из файла
my @cols=split(/,/, $s);                                              # перменная хронящая заголовки колонок
chomp $cols[$#cols];                                                    # удаляем лишние символы
my %length;                                                                 # хэш хронящий макс длины каждого столбца
#my @l = split '',$cols[$#cols];                                    # временный массив для хранения поледней колонки, для удаления последнией гниды (посимвольное предс имени)
#splice @l,$#l;                                                               # удаление последней гниды
#$s='';                                                                            # тут будут символы последнего имени без последней гниды       
#foreach (@l)
#{
 #$s.=$_;                                                                         # посимвольный перенос из символа в строку
#}
#$cols[$#cols]=$s;                                                         # восстановление последнего имени
my @bd;                                                                       # массив с ссылками на хэши (строки бд)

while(<FH>)                                                            # пока не конец файла...
{
 chomp;                                                                       # удаление гнид                                     
 my %mystr=();                                                         # хэш со считанной строкой таблицы                                                              
 my @string= split '', $_;                                            # массив символов строки таблицы из файла
 #splice @string,$#string;                                            # удаление поледней гниды
 my $isQuote=0;                                                       # открыти ли кавычки
 my $i=0;                                                                   # счётчик колонок
 my $elstr;                                                                 # строка с содержимым колонки
 $length{$cols[$i]} = (length $cols[$i])+3;
 my $curlen=0;
 foreach (@string)                                                    # для каждого символа...
 {
  if ($_ eq '"')                                                               # если кавычки....
  {
   if ($isQuote==1) {$isQuote=0;}                            # если кавычки открыты, то закрываем
   else {$isQuote=1;};                                                # иначе открываем
  }
  elsif ($_ eq "," && $isQuote==0)                          # иначе если запятая и кавычки закрыты...
  {
   $mystr{$cols[$i]}=$elstr;                                       # добавляем в хэш по ключю из массива колонок с номером колонки строку с содержимым колонки
   $curlen = $curlen+4;
   if ($curlen > $length{$cols[$i]}) {$length{$cols[$i]}=$curlen;};
   $curlen=0;
   $i++;                                                                        # увеличиваем счётчик колонок
   $elstr="";                                                                 # обнуляем строку содержимого колонки         
  }
  else {$elstr.=$_; $curlen++;};                                                   # иначе добовляем символ к строке содержимого
 }
 $mystr{$cols[$i]}=$elstr;                                        # добавляем в последнюю колонку значение из строки с содержимым
 push @bd,\%mystr;                                                # помещаем в массив ссылку на созданный хэш
};
close FH;                                                                  # закрытие файла

#-----------------------------------------------------------------------SELECT---------------------------------------------------------------------------
if ($query[0] eq 'select')                                         # вызываем подпрограмму производящюю выборку
{
 my @qcols=(split/,/, $query[1]);                               # переменная шранящая список колонок на выходе
 foreach my $i (0..$#query)
 {
   if ($query[$i] eq "orderby")
   {
    if ($query[$i+1] eq "desc")
    {
     @bd = sort {$b->{$query[$i+2]} cmp $a->{$query[$i+2]} }  @bd;
    }
    else
    {
     @bd = sort {$a->{$query[$i+1]} cmp $b->{$query[$i+1]} }  @bd;
    }
   }
 }
 my @where;                                                         # переменная хранящаяя колонки запроса, по которым проевеояются условия
 my @t;                                                                 # временный массив
 my $condtype=$query[5];                                     # пременная отвечающаяя за связь условий {and|or}
 { @t=(split/;/,$query[6]);};                                      # в t получаем условия (вида колонка=знач)
 foreach (@t)                                                        # для каждого t...
 {
  push @where,(split/=/,$_);                                   # помещаем в where имена колонок и значения
 }
 my %where = @where;                                        # формируем хэш ключи которого имена колонок а значения - требуемые
 @where=keys %where;                                                         #  теперь в where только имена колонок, без значений
 if ($qcols[0] eq '*')                                                      # если выбираем все колоники...
 {
  foreach my $i (0..$#cols) 
  {
   $qcols[$i]=$cols[$i];                                                 # поэлементно переносим все элты массива всех колонок в массив запрошенных колонок
  }
 };
 my $name = $query[3]; # получаем имя бд
 my $space = (80 - length $name)/2; # получаем колво "-" до и после имени
 print "\n"; # переводим курсор на новую строку
 print "-" x $space; #выодим "-" до имени
 print uc $name; # выводим имя
 print "-" x $space; # выводим после имени
 print "\n"; # переводим курсор на новую строку
 print "-" x 80; # заполняем новую строку "-"
 print "\n"; # переводим курсор на новую строку
 my $pr; # перменная хронящая суммарную длину выводимых колонок
 foreach my $i (0..$#qcols)                                   # для всех элтов из массива запрошенных колонок
 {
  my $str =$qcols[$i]; # получаем название колонки
  my $len; # длина названия
  $len = $length{$qcols[$i]};
  $pr+=$len+2; # длины колонки к колву выводимых "-"
  while (length $str < $len) # пока длинна строки меньше необходимой....
  {
   $str.=" "; # добавляем пробелы
  }
  print $str                                 # выводим значение запрошенной колонки    
 }
 print "\n";
 print "-" x $pr;
 print "\n";
 my $reccount=0;                                                  # переменная хронящая количество записей удвол условию
 foreach my $j (0..$#bd)                                      # для всех хэшей...
 {
  my $isAccept;                                                     # переменная хранящая удволетворяет ли запис условиям (0 - нет, 1 - да)
  if ($condtype eq "and")                                     # если строка дожна отвечать всем условиям...
  {
   $isAccept=1;                                                      # предпологаем, что строка отвечает всем условиям
   foreach (@where)                                             # для всех колонок, которые учавствуют в условии
   {
     if ($where{$_} ne $bd[$j]->{$_}) {$isAccept=0;};     # если значение колонки не соответствует условию, меняем isAccept
   }
  }
  elsif ($condtype eq "or")                                  # иначе, если строка должна отвечать хотя бы 1 условию
  {
   $isAccept=0;                                                       # предполагаем, что запись не удвол усл
   foreach (@where)                                             # для всех столбцов, которые учавствуют в where...
   {
     if ($where{$_} eq $bd[$j]->{$_}) {$isAccept=1;};  # если хотя бы 1 колонка удвол усл, меняем isAxxept
   }
  }
  else {$isAccept=1;};                                           # в противном случае (не ввели ни and, ни or) isAccept=1
  if ($isAccept == 1)                                             # если строка удвол усл...
  {
   $reccount++;                                                     # увеличиваем счётчик записей
   foreach my $i (0..$#qcols)                                   # для всех элтов из массива запрошенных колонок
   {
    my $str =$bd[$j]->{$qcols[$i]}; # значение колонки
    my $len; # нужная (для красоты)длина строки
    $len = $length{$qcols[$i]};
    while (length $str < $len) # до тех пор пока строка меньше нужной длинны...
    {
     $str.=" ";  # добавляем пробелы
    }
    print $str;                                 # выводим значение запрошенной колонки
   }
   print "\n";                                                               # переводим курсор на новую строку
  }
 }
 my $name = $query[3];  # имя бд
 my $space = (80 - length $name)/2; # колво "-" до и полсле имени
 print "\n";
 print "-" x 80; # заполняем строку "-"
 print "\n"; 
 print "-" x $space; # заполняем пол строки "-"
 print uc $name;  # выводи имя бд "-"
 print "-" x $space; # заполняем ещё пол строки "-"
 print "\n";
 if ($reccount == 0) {print "There are no records, which accept the condition(s)\nTry 'select * from filename'\n";} # если ни1 запис не удвол условию, выводим сообщение
 elsif ($reccount != $#bd+1) {print "$reccount record(s) accept the conditions\n";}
 else {print "In Data Base $reccount record(s)\n";};
}           
#--------------------------------------------------------------------------SELECT------------------------------------------------------------------------
#-----------------------------------------------------------------------------INSERT---------------------------------------------------------------------             
elsif ($query[0] eq 'insert')                         # вызываем подпрограмму производящюю вставку
{
 my @values=split /,/,$query[1];                  #массив хранящий новыу значения
 if ($#values != $#cols)                                  # ecли количество новых значений не ровно количеству столбцов...
 {
  print "Number of values not equal whith nuber of table column\nTry 'select * from filename' to watch how many columns in table\n"; # выводим сообщение о не соответствии
  exit;             # b ds[jlbv
 }
 my %newr; # хэш, хронящий новую строку таблицы
 foreach my $i (0..$#cols) # для всех столбцов
 {
  $newr{$cols[$i]}=$values[$i];   # создаем в хэше новое (указанное) значение, с именем таблицы в качестве ключа
 }
 $bd[$#bd+1]=\%newr;                 # добавляем к массиву хэшей ссылку на только что созданный
 my $f = $query[3];                                                    # имя файла
 open OUT, '>', $f or die "Cannot open file $query[3]: $!";  #Открытие файла на запись или выход из программы в случае невозможности
 foreach my $j (0..$#cols)                                   # для всех элтов из массива запрошенных колонок
 {
  if ($j<$#cols) {print OUT "$cols[$j],";}                                 # имён колонок
  else {print OUT $cols[$j];}                                                    # запись последней колонки без запятой
 }
 print OUT "\n";		                                                             # перевод строки                                         
 foreach my $i (0..$#bd)                                                           # для всех хэшей
 {
   foreach my $j (0..$#cols)                                   # для всех колонок
   {
    if ($j<$#cols) {print OUT "$bd[$i]->{$cols[$j]},";}                                 # записываем в файл значение колонки
    else {print OUT "$bd[$i]->{$cols[$j]}";}                                                 # запись последней колонки без запятой
   }@bd = sort {$a->{$query[$i+1]} cmp $b->{$query[$i+1]} }  @bd;
  if ($i<$#bd) { print OUT "\n";};                                                                 # переход на новую строку
 }	       
}
#-------------------------------------------------------------------------------INSERT-------------------------------------------------------------------
#-------------------------------------------------------------------------------------UPDATE-------------------------------------------------------------
elsif ($query[0] eq 'update')                       # вызываем подпрограмму производящюю обновление
{
 my @where;                                                 # массив хронящий имена колонок на которые наложены условия
 my @t;                                                          # временый массив
 my $condtype=$query[5];                          # перменная хронящая тип условия
 @t=(split/;/,$query[6]);                                # получаем в t условия ф формате имя_колоник=условие
 foreach (@t)                                                # для всех элтов t...
 {
  push @where,(split/=/,$_);                         # помещаем в массив элты (нечётные - имена колонок, чётные значения
 }
 my %where = @where;                               # формируем хэш ключи которого имена колонок а значения - значения
 @where= keys %where;                                                   # теперь в в where только имена колонок учавствующих в условии
 my @values;                                                   # массив который будет хранить имена обновляемых колонок
 @t =undef;                                                      # обнуляем t
 @t=split/;/,$query[1];                                    # получаем в t значения обновлений в формате имя_колонки=новое_значение
 foreach (@t)                                                  # для всех элтов t
 {
   push @values,split/=/,$_;                            # помещаем в values значение (нечётные имена обновляемых колонок, чётные - новые значения
 }
 my %values = @values;                                # формируем хэш ключи которого имена обновляемых колонок а значения - новые значения
 @values=keys %values;                                                    # теперь в values только имена обновляемых колонок
 open OUT, '>', $f or die "Cannot open file $query[3]: $!";  #Открытие файла на запись или выход из программы в случае невозможности
 foreach my $j (0..$#cols)                                   # для всех элтов из массива запрошенных колонок
 {
   if ($j<$#cols) {print OUT "$cols[$j],";}             # пишем в файл имена колонок
   else {print OUT $cols[$j];}                                # пишем последнюю колонку без запятой
 }
 print OUT "\n";	                                                 # переход на новую строку
 my $reccount=0;                                                   # переменная хронящая колво обновлённых записей
 foreach my $j (0..$#bd)                                       # для всех хэшей...
 {
  my $isAccept;                                                       # переменная хронящая удвол ли строка усл
  if ($condtype eq "and")                                       # если тип объед условий = and...
  {
   $isAccept=1;                                                        # предпологаем, что строка удвол усл
   foreach (@where)                                              # для всех колонок учавствующих в условии...
   {
     if ($where{$_} ne $bd[$j]->{$_}) {$isAccept=0;};  # если значение колонки != требуемуму, устанавливаем isAccept
   }
  }
  elsif ($condtype eq "or")                                    # иначе, если тип объед условий = or...
  {
   $isAccept=0;                                                        # предпологаем, что строка неудвол усл
   foreach (@where)                                              # для все строк учавствующих в усл....
   {
     if ($where{$_} eq $bd[$j]->{$_}) {$isAccept=1;};    # если колонка удвол усл, устанавливаем isAccept
   }
  }
  else {$isAccept=1;};                                             # иначе (пользователь ничего не ввёл) все строки удвол усл
  if ($isAccept == 1)                                                # если строка удвол усл...
  {
   $reccount++;                                                        # увеличиваем колво обновлённых записей
   foreach (@values)                                               # для всех обновляемых колонок...
   {
     $bd[$j]->{$_}=$values{$_};                                # устанавливаем новое значение
   }
  }
   my $i;
   foreach $i (0..$#cols)                                   # для всех элтов из массива запрошенных колонок
   {
    if ($i<$#cols) {print OUT "$bd[$j]->{$cols[$i]},";}         # пишем в файл колонки
    else {print OUT "$bd[$j]->{$cols[$i]}";}                         # пишем послденюю колонку без запятой
   }
   if ($i<$#bd) { print OUT "\n";};                                        # переводим курсор на новую строку
 } 
 print "$reccount record(s) was updated\n";       # выводим колво обнавлённых колонок
}
#------------------------------------------------------------------------------------------UPDATE--------------------------------------------------------
#---------------------------------------------------------------------------------------DELETE-----------------------------------------------------------
elsif ($query[0] eq 'delete')                        # вызываем подпрограмму производящюю удаление
{
 my @where;                                                  # массив хронящий условия
 my @t;                                                           # временный массив
 my $condtype=$query[5];                           # получаем тип условия
 @t=(split/;/,$query[6]);                                 # получаем в t условия в формате имя_колонки=требуемое_значение
 foreach (@t)                                                 # для всех усл...
 {
  push @where,(split/=/,$_);                          # получаем в where условия (нечётные - имена колонок, чётные - треб знач)
 }
 my %where = @where;                                 # формируем хэш ключи которого имена усл колонок а значения - треб значения
 @where=%where;                                                   # теперь в where только имена усл колонок
 open OUT, '>', $f or die "Cannot open file $query[3]: $!";  #Открытие файла на запись или выход из программы в случае невозможности
 foreach my $j (0..$#cols)                                   # для всех колонок
 {
  if ($j<$#cols) {print OUT "$cols[$j],";}        # пишем в файл имена колонок
  else {print OUT $cols[$j];}                           # пишем последнюю колонку без запятой
 }
 print OUT "\n";		                                   # переходим на новую строку
 my $reccount=0;                                             # переменная хронящая колво удалённых ячеек      
 foreach my $j (0..$#bd)                                 # для всех хэшей...
 {
  my $isAccept;                                                 # переменная хрон отвечает ли строка усл удоления
  if ($condtype eq "and")                                 # если тип удоления = and...
  {
   $isAccept=1;                                                  # предпологаем, что колнка удвол усл
   foreach (@where)                                        # для всех колонок учавствующих  в усл...
   {
     if ($where{$_} ne $bd[$j]->{$_}) {$isAccept=0;};  # если значение колонки не равно требуемому, устанавливаем isAccept
   }
  }
  elsif ($condtype eq "or")                              # если тип удоления = or...
  {
   $isAccept=0;                                                  # предполагаем, что колонка не удвол усл
   foreach (@where)                                        # для всех колнок учавствующих в усл...
   {
     if ($where{$_} eq $bd[$j]->{$_}) {$isAccept=1;};  # если значение колонки равно требуемому, устанавливаем isAccept
   }
  }
  else {$isAccept=1;};                                       # если юзер ничего не ввёл - не удаялем ни одной строки
  if ($isAccept == 0)                                          # если строка не удвол усл удоления                 
  {
   my $i;
   foreach $i (0..$#cols)                             # для всех колонок
   {
    if ($i<$#cols) {print OUT "$bd[$j]->{$cols[$i]},";}         # пишем колонку в файл
    else {print OUT "$bd[$j]->{$cols[$i]}";}                         # пишем аоследнюю колонку без запятой
   }
  if ($i<$#bd) { print OUT "\n";};                                        # переводим курсор на новую строку
  }
  else {$reccount++};                                          # иначе увеличиваем счётчик удалённых записей
 }
 print "$reccount record(s) was deleted\n";  # сообщаем, сколько записей было удалено
}
#---------------------------------------------------------------------------------DELETE-----------------------------------------------------------------
else                                                                  # иначе... вывод помщи
{
  print "Unexpected query!\n";
  print "Query must be like:\n";
  print "select [*|colsname] from filename [where {{and|or} {cond1;cond2;cond3...}}] [orderby colname [desc]]\n";
  print "update {colname1=value1;colname2=value2...} from filename [where {{and|or} {cond1;cond2;cond3...}}]\n";
  print "insert {value1,value2,...,colnumbers} into filename\n";
  print "delete {*} from filename [where {{and|or} {cond1;cond2;cond3...}}]\n";
}