.model tiny                ; модель памяти, используемая для com
.code                      ; начало сегмента кода
org 100h                   ; начальное значение счётчика - 100h
start:                     ; метка начала программы 
      mov ax,03h           ; функция bios "очистка экрана (или установление в/р)"
      int 10h              ; вызов прерывания для очистки экрана
      mov dx,offset buffer ; помещаем в dx адрес буффера
      mov ah,0Ah           ; функция "считывание строки"
      int 21h              ; вызов прерывания для считывания строки
      mov ah,00h           ; чистка ah
      mov al,[buffer+2]    ; помещаем в al первую считанную цифру
      sub al,'0'           ; вычитаем аски, чтобы получить число
      mov cl,[buffer+1]    ; помещаемв cl длинну реально считанной строки
      cmp cl,02h           ; сравнение cl с 2
      je sdfn              ; если равен, переходим к метке
cont:                      ; метка продолжения для добавления 2 цифры первого числа
      mov bl,al            ; сохраняем полученное число в bl
      mov dx,offset buffer ; помещаемв dl адрес буфера
      mov ah,0Ah           ; функция "считывание строки"
      int 21h              ; вызов прерывания для считывания строки
      mov ah,00h           ; чистка ah
      mov al,[buffer+2]    ; помещаем в al первую считанную цифру
      sub al,'0'           ; вычитаем аски, чтобы получить число
      mov cl,[buffer+1]    ; помещаемв cl длинну реально считанной строки
      cmp cl,02h           ; сравнение cl с 2
      je sdfn              ; если равен, переходим к метке
cont2:                     ; метка продолжения для добавления 2 цифры второго числа
      mov dl,bl            ; помещаем в dl первое число (х)
      mov dh,al            ; помещаем в dh второе число (у) 
      mov ch,dl            ; сохраняем х
      mov ah,02h           ; в ah номер функции bios "управление курсором"  
      int 10h              ; вызов прерывания для установки курсора в (dl,dh) 
 
      mov cl,00h           ; помещаем в cl номер строки (инициализация)
      mov bl,00h           ; помещаем в bl номер столбца (инициализация)
      mov dl,0dbh          ; помещаем в dl аски прямоугольника
cloop:
        int 21h            ; выводим символ
        inc bl             ; увеличиваем счётчик столбцов
        cmp bl,014h        ; если bl не равен 20
        jb cloop           ; переходим на метку (внутренний цикл)
      mov bl,00h           ; иначе обнуляем  
      push dx              ; сохраняем аски символа
      mov dl,0Dh           ; помещаем в dl аски превода коретки 
      int 21h              ; выводим перевод каретки 
      mov dl,0Ah           ; помещаем в dl аски чего-та типа превода коретки 
      int 21h              ; выводим чёта типа 
      mov dl,ch            ; помещаем в dl сохраннёный х
      add dh,cl            ; добавляем к dh (у) номер строки
      int 10h              ; устанавливаем курсор 
      pop dx               ; восстанавливаем dx (аски прямоугольника)
      inc cl               ; увеличиваем счётчик строк
      cmp cl,05h           ; сравниваем счётчик с трок с 5
      jb cloop             ; если не равен - переходим по метке (внешний цикл) 
      mov ah,010h          ; номер функции bios "Чтение символа с ожиданием для 101/102 клавы"
      int 16h              ; вызов прерывания для задержки
      int 20h              ; выход из программы

sdfn:                      ; метка добавления 2 цифры 1 числа  
      mov cl,0Ah           ; 10 в cl
      mul cx               ; умнажаем ax на cl (10)
      xor cx,cx            ; чистим cx
      mov cl,[buffer+3]    ; помещаем в cl аски 2 цифры 1 числа
      sub cl,'0'           ; вычитаем аски "0", чтобы получить число
      add ax,cx            ; добавляем к ax 2 число
      call cont            ; возврат в гл. программу  

sdfn2:                     ; метка добавления 2 цифры 2 числа   
      mov cl,0Ah           ; 10 в cl
      mul cx               ; умнажаем ax на cl (10)         
      xor cx,cx            ; чистим cx
      mov cl,[buffer+3]    ; помещаем в cl аски 2 цифры 2 числа
      sub cl,'0'           ; вычитаем аски "0", чтобы получить число
      add ax,cx            ; добавляем к ax 2 число
      call cont2           ; возврат в гл. программу  

buffer db 3                ; выделение 3 байт для считывания строки (или чёт типа)

      end start            ; конец программы и указание метки начала